[TOC]
# 第四章 变量，作用域和内存问题

## 4.1 基本类型和引用类型的值  

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。  

### 4.1.1 动态属性  

对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法。

```
var person = new Object();
person.name = "aaa";
alert(person.name);  // "aaa"
```

以上代码创建了一个对象并将其保存在了变量person中，然后为该对象添加了一个名为name的属性，并将字符串值“aaa”赋给了这个属性。紧接着，又通过alert()函数访问这个新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。  
但是，不能给基本类型的值添加属性，尽管这样做不会导致任何错误。

```
var name = "aaa";
name.age = 27;
alert(name.age);  // undefined
```

### 4.1.2 复制变量值  

如果一个变量像另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
```
var num1 = 5;
var num2 = num1;
```
如图展示复制基本类型值的过程  
![Copy1](https://github.com/LinkStarted/ProfessionalJavaScriptforWebDevelopers/blob/master/Copy1.JPG)  
在此，num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5.但num2中的5与num1中的5完全独立，该值只是num1中的5的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。  

当从一个变量向另一个变量复制引用类型的值是，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值得副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。
```
var obj1 = new Object();
var obj2= obj1;
obj1.name = "aaa";
alert(obj2.name);  // "aaa"
```
如图所示保存引用类型值得过程  
![Copy2](https://github.com/LinkStarted/ProfessionalJavaScriptforWebDevelopers/blob/master/Copy2.JPG)   

首先，变量obj1保存了一个对象的新实例。然后这个值被复制到了obj2中；换句话说，obj1和obj2都指向同一个对象。这样，当为obj1添加name属性后，可以通过obj2来访问这个属性，因为这两个变量引用的都是同一个对象。

### 4.1.3 传递参数  

==ECMAScript中所有函数的参数都是按值传递==  

### 4.1.4 检测类型  

typeof操作符是确定一个变量是字符串，数值，布尔值，还是undefined的最佳工具。如果变量的值是一个对象或者null，则typeof操作符会返回object。  
instanceof用来检测是什么类型的对象。
`result = variable instancof constructor`
根据规定，所有引用类型的值都是Object的实例，因此，在检测一个引用类型的值和object构造函数时，instanceof操作符始终会返回true，而在检测基本类型的值时，始终返回false，因为基本类型不是对象。  

## 4.2 执行环境及作用域  

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前那的执行环境。
当代码在一个环境中执行时，会创建变量对象的**作用域链**。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。  
标识符解析是沿着作用域链一级一级的搜索标识符的过程。搜索过程始终从作用域链的前段开始，然后逐级向后回溯，直到找到为止，如果找不到，通常会发生错误。  

### 4.2.1 延长作用域链  

虽然执行环境的类型总共只有2中--全局和局部(函数)。但还是有其他办法来延长作用域链。
当执行流进入下列任何一个语句时，作用域链就会得到加长：  

+ try-catch语句的catch块；
+ with语句
  
这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。  

例：
```
function buildUrl(){
    var qs = "?debug=true";
    with(location){
        var url = href +qs;
    }
    return url;
}
```
### 4.2.2 没有块级作用域

#### 4.2.2.1 声明变量  

使用var声明变量会自动被添加到最近的环境中。在函数内部，最接近的换进就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。  

#### 4.2.2.2 查询标识符  

当某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象，如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。  

## 4.3 垃圾收集  

JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。

垃圾收集的2中方法
+ 标记清除
+ 引用计数

为了确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要数据。一旦数据不再游泳，最好通过将其值设置为null来释放其引用--这个方法叫做**解除引用**。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自定被解除引用。不过，接触一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 4.4 小结  

JavaScript变量可以用来保存两种类型的值：基本类型和引用类型值。基本类型的值源自一下5种基本数据类型：undefined，null，boolean，number，string。基本类型和引用类型值具有一下特点：

+ 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
+ 从一个变量像另一个变量复制基本类型的值，会创建这个值的副本；
+ 引用类型的值是对象，保存在堆内存中；
+ 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
+ 从一个变量向另一个变量赋值引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
+ 确定一个值是哪种基本类型使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。

所有变量（包括基本类型和引用类型）都存在与一个执行环境（也称作用域）中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：

+ 执行环境有全局执行环境和函数执行环境之分；
+ 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
+ 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
+ 全局环境只能访问全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
+ 变量的执行环境有助于确定应该何时释放内存。

javaScript是一门具有自动垃圾回收机制的编程语言，开发人员不必关心内存分配和回收问题。意义对JavaScript的垃圾收集做如下总结：

+ 离开作用域的值将被自动标记为可回收，因此将在垃圾收集期间被删除；
+ “标记清除”是目前主流的垃圾回收算法，这种算法的思路是给当前不使用的值加上标记，然后再回收其内存；
+ 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数，JavaScript引擎目前都不再使用这种算法，但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能导致问题；
+ 当代码中存在循环引用现象时。“引用计数”算法会导致问题；
+ 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾回收也有好处。为了确保有效的回收内存，应该及时解除不再使用的全局对象，全局对象属性以及循环引用变量的引用。
