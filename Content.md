[TOC]
# 第一章 JavaScript简介

## 1.1 JavaScript实现 

**完整的JavaScript由3个部分组成:**  
1. ECMAScript(European Computer Manufacturers Association)
2. DOM
3. BOM

## 1.2 ECMAScript
- ECMAScript-262定义的这门语言的基础
- ECMAScrpt规定了语言由以下部分组成：  
    * 语法
    * 类型
    * 语句
    * 关键字
    * 保留字
    * 操作符
    * 对象

## 1.3 文档对象模型 DOM  
DOM是针对XML但经过扩展用于HMTL的应用程序编程接口(API)。  
DOM把整个页面映射为一个多层节点结构。  

### 1.3.1 DOM级别
- DOM1级：由2个部分组成
    + DOM核心： 规定的是如何映射基于XML的文档结构；
    + DOM HTML： 在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。
- DOM2级： 引入以下新模块：
    + DOM视图(DOM View)： 定义了跟踪不同文档(如：应用CSS前后的文档)视图的接口；
    + DOM事件(DOM Event): 定义了事件和事件处理接口；
    + DOM样式(DOM Style)： 定义了基于CSS为元素应用样式的接口；
    + DOM遍历和范围(DOM Traversal and Range)： 定义了遍历和操作文档树的接口。
- DOM3级： 进一步扩展DOM  
    + DOM加载和保存(DOM Load and Save)
    + DOM验证(DOM Validation)  

## 1.4 浏览器对象模型 BOM  

从根本上讲，BOM只处理浏览器窗口和框架；但人们也习惯把所有针对浏览器的JavaScript扩展算作BOM的一部分：  

- 弹出新浏览器窗口的功能；
- 移动，缩放和关闭浏览器的功能；
- 提供浏览器详细信息的navigator对象；
- 提供浏览器所加载页面详细信息的location对象；
- 提供用户显示器分辨率详细信息的screen对象；
- 对cookie的支持；
- 像XMLHTTPRequest和IE的ActiveXObject 这样的自定义对象。

## 1.5 小结

JavaScript是一种专为与网页交互设计的脚本语言，由下列三个不同部分组成：

- ECMAScript： 由ECMAScript-262定义，提供核心语言功能；
- 文档对象模型(DOM)： 提供访问和操作网页内容的方法和接口；
- 浏览器对象模型(BOM)： 提供与浏览器交互的方法和接口。


# 第二章 在HTML中使用JavaScript

## 2.1 `<script>` 元素  

**`<script>`定义了6个元素**  

- async : 可选。表示立即下载脚本，但不妨碍页面中的其他操作，不如下载其他资源或等待加载其他脚本。==只针对外部脚本有效==。
- charset : 可选。表示通过src属性指定的代码的字符集。由于==大多数浏览器会忽略它的值==。因此这个属性很少有人用。
- defer ： 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。==只对外部文件有效==。
- language : 已废弃。
- src ： 可选。表示包含执行代码的外部文件。
- type : 可选。 可以看做是language的代替属性：表示编写代码使用脚本语言的内容类型(也称为==MIME类型==)。虽然text/javascript和text/ecmascript都以不推荐使用。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x-javascript。如果没有指定这个属性，其默认值仍为text/javascript。  


**使用`<script>`的2种方法：**  

1. 在页面中嵌入JavaScript代码；
2. 引用外部JavaScript文件。  

在包含`<script>`元素内部的JavaScript代码将被==从上至下==依次解释。  
在解释器对`<script>`元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。  
在使用`<script>`嵌入JavaScript代码时，浏览器遇到字符串`</script>`就会认为是结束标志。需要通过转义字符`\`解决。  

引用外部JavaScript文件  
`<script src="文件名.js"></script>`  
如果在`<script>`和`</script>` 之间嵌入代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。  
scr属性还可以包含来自外域的JavaScript文件。  
无论如何包含代码，只要不存在defer和async属性，浏览器都会按照`<script>`元素在页面中出现的先后顺序对它们依次进行解析。  

### 2.1.1 标签位置

1. 在`<head>`元素中：这种做法必须等所有的JavaScript代码都被下载，解析和执行完以后才能开始呈现页面内容；
2. 在`<body>`元素底部： 在页面内容完全呈现在浏览器之后再解析JavaScript代码，缩短空白页面的显示时间，从而感觉打开页面速度加快。

### 2.1.2 延迟脚本

`<script type="text/javascript" defer="defer" scr="example.js"></script>`  
defer属性的脚本会被延迟到整个页面都解析完毕后再运行。  
HTML5规范要求脚本按照他们出现的先后顺序执行，因此第一个延迟脚本会优先第二个延迟脚本执行，而且脚本会优先于`DOMContentLoaded`事件执行。但在现实中，延迟脚本不一定会按照顺序执行，也不一定会在`DOMContentLoaded`事件触发前执行，因此==最好只包含一个延迟脚本==。  
defer属性只适用于外部脚本文件。

### 2.1.3 异步脚本  

`<script type="text/javascript" async scr="example.js"></script>`   
async属性只适用于外部脚本文件。
async属性不能保证按照指定它们的先后顺序执行，因此要确保脚本之间互不依赖。
async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面的其他内容。建议异步脚本不要在加载期间修改DOM。
异步脚本一定会在页面的load事件前执行，但可能会在`DOMContentLoaded`事件触发之前或之后执行。

## 2.2 嵌入代码和外部文件

使用外部文件的优点：

- 可维护性
- 可缓存
- 适应未来

## 2.3 文档模式 
IE5.5引入了文档模式的概念，通过文档类型(doctype)来实现。最初的2种文档模式是：==混杂模式和标准模式==。

HTML5文档模式： `<!DOCTYPE HTML>`

## 2.4 `<noscript>`元素
为了早期那些不支持JavaScript的浏览器而使用的元素。

`<noscript>`元素中的内容在下列清空中显示： 

- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用。

满足以上任何一个条件，浏览器都会显示`<noscript>`中的内容，其他情况都不会显示。


```
<html>
    <head>
        <title>123</title>
        <script></script>
    </head>
    <body>
        <noscript>
            <p>本页面需要浏览器启用JavaScript</p>
        </noscript>
    </body>
</html>
```

## 2.5 小结
使用`<script>`元素吧JavaScript嵌入到HTML中。  
在使用中需要注意：

- 在包含外部JavaScript文件时，必须将src属性设置为指向相应文件件的URL。而这个文件可以是与包含它的页面位于同一个服务器上文件，也可以是其他任何域中的文件。
- 所有`<script>`元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer和async属性的情况下，只有在解析完前面`<script>`元素中的所有代码之后，才会开始解析下一个
`<script>`元素中的代码。
- 由于浏览器会先解析完不使用defer使用的`<script>`元素中的代码，然后再解析后面的内容，所以一般应该把`<script>`元素放在页面的最后，即`</body>`标签前。
- 使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。
- 使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。


# 第三章 基本概念  

## 3.1 语法  

### 3.1.1 区分大小写  

在ECMAScript中的一切都是区分大小写。  

### 3.1.2 标识符

标识符，就是指变量，函数，属性的名字，或者函数的参数。  
标识符是按照以下规则组合起来的一个或多个字符：  

- 第一个字符必须一个字母，下划线或者美元符号；
- 其他字符可以是字母，下划线，美元符号或数字。

标识符中的字母也可以包含扩展的ASCII或者Unicode字母字符。
ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。

### 3.1.3 注释  

`//单行注释`

```
/*
*  多行注释
*
*/
```

### 3.1.4 严格模式

要在整个脚本中启用严格模式，可以在顶部添加如下代码：  
`"use strict"`  

### 3.1.5 语句  

语句以分号结尾。

## 3.2 关键字和保留字

ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或者结束，或者用于执行特定操作等。关键字不能用作标识符。ECMAScript的所有关键字：  

  | | | | |
---|---|---|---
break | do | instanceof | typeof  
case | else | new | var  
catch | finally | return | void 
continue | for | switch | while 
debugger | function | this | with 
default | if | throw | 
delete | in | try|

还有一组不能用作标识符的保留字。  

 | | | | |
 ---|---|---|---
 abstract | enum | int | short 
boolean | export | interface | static 
byte | extends | long | super 
char | final | native | synchronized 
class | float | package | throws 
debugger | implements | protected | volatile 
double | import |public |
let | yield | 

## 3.3 变量 

ECMAScript的变量是松散的，可以保存任何数据类型。   
定义变量时使用`var`操作符。

## 3.4 数据类型 

### 3.4.1 typeof操作符

typeof是用来检测给定变量的数据类型的操作符，它的返回值有： 

- "undefined" : 值未定义；
- "boolean" ： 布尔值；
- "string" : 字符串；
- "number" : 数值；
- "object" : 值是对象或者null；
- "function" : 值是函数。 

### 3.4.2 undefined类型 

undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。  

对于为声明的变量，只能执行一项操作，即使用typeof操作符检测数据类型，它的返回值也是undefined。


### 3.4.3 null类型  

null类型是第二个只有一个值得数据类型，这个值是null。从逻辑角度看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值是返回 "object" 的原因。

undefined值派生自null值，因此ECMA-262规定他们的相等性测试要返回true。  
`alert(null == undefined);  //true`  

### 3.4.4 boolean类型 

Boolean 类型只有2个字面值：true和false。  这2个值是区分大小的，也就是说，True和False都不是boolean值，是标识符。  
对于任何数据类型的值调用Boolean()函数，总会返回一个Boolean值。各个数据类型和Boolean的转换规则：  

 |数据类型 | 转换为true的值 | 转换为false的值 |
 --- | --- | ---
 Boolean | true | false |
 String | 任何非空字符串 | “”（空字符串）|
 Number | 任何非零数字值（包括无穷大） | 0 和NaN | 
 Object | 任何对象 | null | 
 Undefined | 不适用 | undefined | 

### 3.4.5 Number类型  

Number类型使用IEEE754格式来表示整数和浮点数。  

`var num1 = 55;`  十进制整数  
`var num1 = 070;` 八进制的56  
`var num1 = 079;` 无效的八进制数  
`var num1 = 0x1f;` 十六进制的31  

在进行算数运算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。  

#### 浮点数值  

浮点数的数值中必须包含一个小数点，并且小数点后面必须至少有一个数字。
由于保存浮点数值需要的内存空间是保存整数值的2倍，因此ECMAScript回会将浮点值转化为整数值：  
`var floatNumber1 = 1.` 小数点后面没有数字，解析为1  
`var floatNumber1 = 10.0` 整数，解析为10  

对于那些极大或极小的数值，可以用e(科学计数法)表示。在默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以科学技术法。  

浮点数值最高精度是17位小数。但在进行算数运算时其精度远不如整数，如0.2+0.1得到的不是0.3，而是0.30000000000000004，这个误差会导致无法测试特定的浮点数值。  

#### 数值范围  

EMCAScript能够表示的最小数值保存在 Number.MIN_VALUE 中，大多数浏览器中，这个值是5e-324；  
EMCAScript能够表示的最大数值保存在 Number.MAX_VALUE 中，大多数浏览器中，这个值是 1.7976931348623157e+308。  

如果超出了数值范围，这个值会被自动转换成Infinity值；如果是负数，则会被转换成-Infinity；如果是正数，则会转换成Infinity。 Infinity值无法参与下一次的计算。  

使用函数 `isFinite()` 来判断参数是否在最小值和最大值之间。如果是，返回true，否则返回false。  

#### NaN 

NaN(Not a Number)，表示一个本来要返回数值的操作数为返回数值的情况(这样就不会抛错)。  
NaN有2个特点：  

- 任何涉及NaN的操作都会返回NaN
- NaN 与任何值不相等，包括NaN本身
  
基于以上2个特点，ECMAScript定义了`isNaN()`函数。 `isNaN()`在接受到一个值后会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。  
`alert(isNaN(NaN))` // true  
`alert(isNaN(10))`  // false(10是一个数值)  
`alert(isNaN("10"))`  // false（可以被转换成数值10）  
`alert(isNaN("bule"))`  // true（不能转换成熟知）
`alert(isNaN(true))` // false （可以被转换成数值1）  

#### 数值转换  

3个函数可以把非数值转换为数值： `Number()`, `parseInt()`, `parseFloat`  

`Number()` 函数的转换规则如下：  

- 如果是Boolean值。true和false将分别被转换为1和0
- 如果是数字值，只是简单的传入和传出
- 如果是null，返回0
- 如果是undefined， 返回NaN
- 如果是字符串，遵循下列规则：  
  * 如果字符串中只包含数字（包括前面带正负号的情况），将其转换为十进制数值，即 “123”变成123，“0456”变成456（前面的0会被忽略）
  * 如果字符串中包含有效的浮点格式，如“1.1”，则将其转换为对应的浮点数值，同样会忽略前导0
  * 如果字符串包含有效的十六进制格式，如“0xf”，则将其转换为相同大小的十进制数值
  * 如果字符串是空的，则将其转换为0
  * 如果字符串包含上述格式之外的字符，则将其转换为NaN
- 如果是对象，则调用对象的`ValueOf()`方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的`toSting()`方法，然后再次依照前面的规则转换返回的字符串值。
  
`Numbrer("Hello World")` // NaN  
`Numbrer("1.1.1")`  // NaN  
`Numbrer("")` // 0  
`Numbrer("00011")`  // 11  
`Numbrer("true")` // 1  

`Number()`在转换字符串是比较复杂而且不够合理，因此在处理整数是更常用的是`parseInt()`函数  
`parseInt()`函数在转换字符串时会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者正负号，`parseInt()`函数返回NaN。  
`parsrInt("   123bule")` // 123  
`parsrInt("")` // NaN  
`parsrInt("0xA")` // 10 十六进制数  
`parsrInt("22.5")` // 22
`parsrInt("070")`  // 56 八进制数
`parsrInt("70")`  // 70 十进制数  

`parsrInt("070")` 在ES3引擎中“070”会被认为是八进制数，而在ES5引擎中，会被认为是十进制数，因此可以为`parseInt()`函数提供第二个参数：进制数，即`parseInt(字符串，进制数)`  
`parseInt(“AF”，16)` //175  
`parseInt(“AF”)`  // NaN 

`parseFloat()`与`parseInt()`类似，`parseFloat()`也是从第一个字符开始解析每个字符，一直解析到字符串末尾，或者遇到一个无效的浮点数字字符为止，也就是说，字符串的第一个小数点是有效的，第二个以及之后的字符串就无效了。  

`parseFloat()`只解析十进制格式，如果是十六进制的格式的字符串始终会被转换为0  
如果字符串包含的是一个可以解析为整数的数（没有小数点或者小数点后为0），`parseFloat()`会返回整数。  
`parseFloat(“123bule”)` // 123 整数  
`parseFloat(“0xA”)` // 0  
`parseFloat(22.5)`  // 22.5  
`parseFloat(22.5.4)`  // 22.5  
`parseFloat(0908.5)`  // 908.5  
`parseFloat(“3.12e2”)` // 312
`parseFloat(“..0”)` // NaN  

### 3.4.6 String类型  

String类型用于表示由零或者多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号或者单引号表示。  

#### 字符字面量

String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

|字面量|含义|
---|---|
`\n` | 换行
`\t` | 制表
`\b` | 空格
`\r` | 回车
`\f` | 进纸
`\\` | 斜杠
`\'` | 单引号，在单引号表示的字符串中使用
`\"` | 双引号，在双引号表示的字符串中使用
`\xnn` | 以十六进制代码nn表示一个字符，其中n为0～F
`\unnnn` | 以十六进制代码nnnn不碍事一个unicode字符

字符字面量可以出现在字符串的任意位置，而且也被作为一个字符来解析。  

#### 字符串的特点

ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建他们的值就不能改变。要改某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。例如：  
```
var lang = "Java";
lang = lang + "Script";
```
以上示例中的lang开始时包含字符串“Java”。而第二行代码把lang值重新定义为“Java”与“Script”的组合。实现这个操作的过程如下：  

- 首先创建一个能容纳10个字符的新字符串，
- 然后在这个字符串中填充“Java”和“Script”，
- 最后销毁原来的字符串“Java”和“Script”，因为这2个字符串已经没用了。

#### 转换为字符串  

`toStirng()`方法和转型函数`Stirng()`。  

`toStirng()`：几乎每个值都有这个方法，它唯一要做的就是返回相应值的字符串表现。  
数值，布尔值，对象和字符串值都有`toStirng()`方法，但null和undefined值没有。  

`toStirng()`方法，在多数情况下不必传递参数，但在调用数值的`toStirng()`方法时，可以传递进制数作为参数来改变`toStirng()`方法输出的值。  

`Stirng()`：这个函数能够将任何类型的值转换为字符串。转换规则如下：  

- 如果值友有`toStirng()`方法，则调用该方法并返回相应的结果；
- 如果值是null，则返回“null”；
- 如果只是undefined，则返回“undefined”。  

 
### 3.4.7 Object类型

ECMAScrit中的对象其实就是一组数据和功能的集合。对象可以通过new操作符后跟要创建的对象类型的名称来创建。而创建Object类型的实例并为其添加属性和方法，就可以创建自定义对象。  
`var o = new Object();`  
在ECMAScrit中Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法夜夜同样存在于更具体的对象中。
Object的每个实例都具有下列属性和方法：  

- `constructor`： 保存着用于创建当前对象的函数。
- `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，其中作为参数的属性名（propertyName）必须以字符串形式制定
- `isPrototypeOf(Object)`： 用于检查传入的对象是否是传入对象的原型。
- `propertyIsEnumerable(propertyName)`： 用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()一样，作为参数的属性名必须以字符串形式指定。
- `toLocaleString()`: 返回对象的字符串表示，该字符串与执行环境的地区对应。
- `toString()`： 返回对象的字符串表示。
- `valueOf()`: 返回对象的字符串，数值或布尔值表示。通常与toString()方法的返回值相同。

  
## 3.5 操作符 

操作符包括： 算术操作符，位操作符，关系操作符和相等操作符。  

### 3.5.1 一元操作符  

#### 递增递减操作符

递增：++
递减：--

```
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;  // (20-1)+2=21
var num4 = num1 +num2;     // 19+2=21
```
```
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;  // 20+2=22, 20-1=19
var num4 = num1 +num2;     // 19+2=21
```

递增递减操作符对于任何值都适用，不仅适用于整数，还可以用于字符串，布尔值，浮点数值和对象。在应用于不同的值时，遵循下列规则：  

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，在执行加减1的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设为NaN。字符串变量变成数值变量。
- 在应用于布尔值false时，先将其转换为0在执行加减1的操作。布尔值变量变成数值变量。
- 在应用于布尔值true时，先将其转换为1在执行加减1的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减1操作。
- 在应用于对象时，先调用对象的ValueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则再调用toString()方法后再应用前述规则。对象变量变成数值变量。

```
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = (
    valueOf: function(){
        return -1;
    }
);

s1++;  //3
s2++;  //NaN
b++;  // 1
f--;  //0.100000000009(由于浮点舍入错误)
o--;  //-2
```

#### 一元加和减操作符

加： +
减： -

加号放在数值前面，对数值不会产生任何影响；减号放在数值前面，数值变成负数。

对于非数值，加号会像Number()转型函数一样对这个值执行转换；减号会将转换得到的值再转换成负数。  

### 3.5.2 位操作符  

位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。 EMCAScript中的所有数值都以IEEE-754 64位格式存储。但位操作符并不直接操作64位的值。而是现将64位的值转换成32位的整数，然后执行操作。最后再将结果转换回64位。  
对于有符号的整数，32位中的前31位表示数值，第32位表示数值的符号，即符号位，0表示正数，1表示负数。  
负数以二进制补码的形式存储；计算二进制补码的步骤：  

- 求这个数绝对值的二进制码；
- 求二进制反码；
- 反码加1.

#### 按位非（NOT）

使用波浪线（`～`）表示，按位非操作的本质： 操作数的负值减1；  

#### 按位与 (AND) 

使用`&`表示。

| 第一个数值的位 | 第二个数值的位 | 结果 |
---|---|---|
1 | 1 | 1 |
1 | 0 | 0 |
0 | 1 | 0 |
0 | 0 | 0 | 

#### 按位或 (OR) 

使用 `|` 表示。  

| 第一个数值的位 | 第二个数值的位 | 结果 |
---|---|---|
1 | 1 | 1 |
1 | 0 | 1 |
0 | 1 | 1 |
0 | 0 | 0 | 

#### 按位异或 (XOR) 

使用 `^`表示。  

| 第一个数值的位 | 第二个数值的位 | 结果 |
---|---|---|
1 | 1 | 0 |
1 | 0 | 1 |
0 | 1 | 1 |
0 | 0 | 0 | 

#### 左移 

左移操作符由2个小于号(`<<`)表示。这个操作符会将数值的所有位向左移动指定位数。左移以0填充空位。左移不会影响符号位。

Q:为什么没有无符号左移？
A：左移是在末尾补0，不会影响数值的正负；而右移是在开头填充数字，所以会有补0或1的区别。

#### 右移

有符号右移操作符由2个大于号(`>>`)表示，这个操作符会将数值向右移动，但保留符号位。

#### 无符号右移

无符号右移操作符由三个大于号表示(`>>>`)，这个操作符会将数值的所有32位都向右移动。


### 3.5.3 布尔操作符

布尔操作符一共有3个：非，与，或。

#### 逻辑非

逻辑非由一个感叹号(`!`)表示，可以用于ECMAScript中的任何值。

| 操作数 | 结果 |
---|---|
对象 | false |
空字符串 | true |
非空字符串 | false |
数值0 | true |
任意非0数值(包括Infinity) | false |
null | true |
NaN | true |
undefined | true |

#### 逻辑与 

逻辑与操作符由2个和号(`&&`)表示。

| 第一个操作数 | 第二个操作数 | 结果 |
---|---|---|
true | true | true |
true | false | false |
false | true | false |
false | false| false |

逻辑与操作符可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：  

- 如果第一个操作数是对象，而则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数为true的情况下才会返回该对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数为null，则返回null；
- 如果有一个操作数为NaN, 则返回NaN；
- 如果有一个操作数为undefined。则返回undefined。

逻辑与属于==短路操作==，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。  

#### 逻辑或  

逻辑或操作符由两个竖线符号(`||`)表示.

| 第一个操作数 | 第二个操作数 | 结果 |
---|---|---|
true | true | true |
true | false | true |
false | true | true |
false | false| false |

如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值：  

- 如果第一个操作数是对象，而则返回第一个操作数；
- 如果第一个操作数的求值结果为false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果有两个操作数为null，则返回null；
- 如果有两个操作数为NaN, 则返回NaN；
- 如果有两个操作数为undefined。则返回undefined。

逻辑或属于==短路操作==。  

### 3.5.4 乘性操作符  

EMCAScript定义了3个乘性操作符：乘法，除法和求模。  

#### 乘法

乘法操作符由一个星号(`*`)表示。

在处理特殊值得情况下，乘法操作符遵循下列特殊规则：  

- 如果操作数都是数值，执行常规的乘法计算，乘积超出数值的表示返回，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity于0相乘，结果是NaN；
- 如果是Infinity于非0数值相乘，则结果是Infinity或-Infinity；
- 如果是Infinity于Infinity相乘，则结果是Infinity；
- 如果有一个操作数不是数值，则再后台调用Number()将其转换为数值，然后再应用上面的规则。  

#### 除法 

除法操作符由一个斜线符号(`/`)表示。 

在处理特殊值得情况下，遵循下列特殊规则：  

- 如果操作数都是数值，执行常规的除法计算；如果商超出了数值表示范围，则返回Infinity或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity被Infinity除，则结果是NaN；
- 如果是0被0除，则结果是NaN；
- 如果是非0的有限数被0除，则结果是Infinity或-Infinity；
- 如果是Infinity被任何非0数值除，则结果是Infinity或-Infinity；
- 如果有一个操作数不是数值，则再后台调用Number()将其转换为数值，然后再应用上面的规则。
- Infinity/0,结果为Infinity；
- 0/Infinity,结果为0；

#### 求模  

求模操作数由一个百分号(`%`)表示。

在处理特殊值得情况下，遵循下列特殊规则： 

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的值，则结果是NaN；
- 如果被除数是有限大的数值而除数是0，则结果是NaN；
- 如果是Infinity被Infinity除，则结果是NaN；
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是0，则结果是0；
- 如果有一个操作数不是数值，则再后台调用Number()将其转换为数值，然后再应用上面的规则。  

### 3.5.5 加性操作符  

#### 加法 

加法操作符(`+`),用法如下：  

- 如果两个操作符都是数值，执行常规的加法计算；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity加Infinity，则结果是Infinity；
- 如果是-Infinity加-Infinity，则结果是-Infinity；
- 如果是Infinity加-Infinity，则结果是NaN；
- 如果是+0加+0，则结果是+0；
- 如果是-0加-0，则结果是-0；
- 如果是+0加-0，则结果是+0；
- 如果两个操作数都是字符串，则将第二个操作数于第一个拼接起来；
- 如果只有一个操作数是字符串，则将另一个操作数转换成字符串，然后再将两个字符串拼接起来。

#### 减法  

减法操作符(`-`)，用法如下：  

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity减Infinity，则结果是NaN；
- 如果是-Infinity减-Infinity，则结果是NaN；
- 如果是Infinity减-Infinity，则结果是Infinity；
- 如果是-Infinity减Infinity，则结果是-Infinity；
- 如果是+0减+0，则结果是+0；
- 如果是+0减-0，则结果是-0；
- 如果是-0减-0，则结果是+0；
- 如果有一个操作数是字符串，布尔值，null，undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算，如果转换的结果是NaN，则减法的结果是NaN；
- 如果有一个操作数的对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。  

### 3.5.6 关系操作符  

小于(`<`)，大于(`>`)，小于等于(`<=`)，大于等于(`>=`)的操作符返回值都是一个布尔值。  
当关系操作符的操作数使用了非数值是，也要进行数据转换或者完成某些奇怪的操作，以下就是相应的规则。  

- 如果两个操作数都是数值，则执行数值比较；
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值；
- 如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较；
- 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作是布尔值，则现将其转换为数值，然后再执行比较。

NaN在进行比较时，结果总为false；  

### 3.5.7 相等操作符  

相等操作符有两组操作符：  

- 相等和不相等： 先转换再比较；
- 全等和不全等： 仅比较而不转换。

#### 相等和不相等  

相等操作符由两个等于号(`==`)表示；不相等操作符由叹号后跟等于号(`!=`)表示。

在转换不同数据类型是，相等和不相等操作符遵循下列基本规则：  

- 如果有有一个操作数是布尔值，则在比较相等性之前先将其转换为数值：false转换为0，true转换为1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前现将字符串转换为数值；
- 如果一个操作数是对象，另一个不是，则调用对象的valueOf()方法，用得到的基本类型按照前面的规则进行比较；
  
这两个操作符在进行比较时则要遵循下列规则：  

- null和undefined是相等的；
- 要比较相等性之前，不能将null和undefined转换成其他任何值；
- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，NaN不等于NaN；
- 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则返回false。

下表列出一些特殊情况和比较结果：  
|表达式|值|
---|---|
null == undefined | true |
“NaN” == NaN | false |
5 == NaN | false |
NaN == NaN | false |
NaN != NaN | true |
false == 0 | true |
true == 1 | true |
true == 2 | false |
undefined == 0 | false |
null = 0 | fasle |
“5” == 5 | true | 

#### 全等和不全等  

全等： `===`
不全等 ： `!==`

记住： null == undefined 会返回true，因为他们是类似的值；但null === undefined会返回false。因为他们是不同类型的值。

### 3.5.8 条件操作符  

`variable = boolean_expression ? true_value : false_value`

本质上，这行代码的含义是基于对boolean_expression求值的结果，决定给变量variable赋什么值。  

### 3.5.9 赋值操作符  

简单的赋值操作符由等于号(`=`)表示。
复合赋值操作符：  

- 乘赋值：`*=`
- 除赋值：`/=`
- 模赋值：`%=` 
- 加赋值：`+=`
- 减赋值：`-=`
- 左移赋值：`<<=`
- 有符号右移赋值：`>>=`
- 无符号右移赋值： `>>>=`

设计这些操作符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。

### 3.5.10 逗号操作符  

使用逗号操作符可以在一条语句中执行多个操作。
逗号操作符用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达是中的最后一项。  

## 3.6 语句  

### 3.6.1 if语句  

```
if(condition){
    statement1
}else{
    statement2
}
```

### 3.6.2 do-while语句  

do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。  

```
do{
    statement
}while(expression);
```

### 3.6.3 while语句  

while语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。

```
while(expression) {
    statement1
}
```

### 3.6.4 for语句

